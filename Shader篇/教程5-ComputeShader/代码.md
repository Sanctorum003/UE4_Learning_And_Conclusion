详细的计算着色器的知识可以看
> https://www.cnblogs.com/lonelyxmas/p/10817176.html
# Computer Shader原理图
![](threadgroupids.png)
* dispatch(5,3,2)
> 生成一张 5*3*2 的线程组表  
* SV_GroupID(2,1,0)
> 线程组表中位置为(2,1,0)的线程组
* numthreads(10,8,3)
> 生成一张 10*8*3的线程表，每个位置代表一个线程
```cpp
RWTexture2D<uint> OutputSurface;

[numthreads(32,32,1)]
void MainCS(uint3 ThreadID:SV_DispatchThreadID)
```
该结构使得OutputSurface在x和y方向可以同时由32个线程并行计算

# FMyComputeShader中的一些问题
## UAV
* Unordered Access View(UAV)
> 无序访问视图（UAV）是无序访问资源的视图（可以包括缓冲区，纹理和纹理数组，尽管没有多重采样）。
UAV允许从多个线程暂时进行无序的读/写访问(一种组织结构，可以无序访问)  
> 绑定输出资源到CS，需要新的视图类型unordered access view (UAV)
## RHICmdList
* RHI是Render Hardware Interface，程序通过它去调用图像库（dx,opengl等）
* RHICmdList即RHI命令列表

# usf中的一些问题
## RWTexture2D
* 可读可写2D材质

# UseComputeShader_RenderThread中的一些问题
```cpp
FTexture2DRHIRef Texture = RHICreateTexture2D(SizeX, SizeY, PF_A32B32G32R32F, 1, 1, TexCreate_ShaderResource | TexCreate_UAV, CreateInfo);
```
这句语句使生成的texture既可以作为shader resource也可以作为UAV

# 梳理
![](cs_summary.png)
https://www.cnblogs.com/lonelyxmas/p/10817176.html
https://blog.csdn.net/qq_18229381/article/details/86741354